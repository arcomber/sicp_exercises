Ex 1.2

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

=  - 37
    ---
    150

numerator = 14 4/5

denominator = -60


Ex 1.3

(define (sum_sq_largest x y z)
       (cond ((and (< x y) (< x z)) (+ (square y) (square z)))
             ((and (< y x) (< y z)) (+ (square x) (square z)))
             (else (+ (square x) (square y)))))


Ex 1.4

(define (a-plus-abs-b a b)
  (
    (if (> b 0) + 
                -)
       a b)
  )

I think that if (> b 0) condition means + is used otherwise - is used.

So using substitution model:

(a-plus-abs-b 2 3)
(+ 2 3)
5

or alternatively:
(a-plus-abs-b 2 -3)
(- 2 -3)
5

ie 2 - -3

I think the key thing here is that there are two steps above.  First the check whether b is +ve or -ve then 
the corresponding addition or subtraction of a and b

Ex 1.5

The key to answering this question is understanding (define (p) (p))

This function evaluates to ... itself.  so it recursively keeps calling itself - so it never ends.

Therefore, behaviour will be different for normal order and applicative order.

With applicative order, the arguments are evaluated before the function body.  hence (test 0 (p)) will evaluate (p) before any of its body and hence be stuck in an endless loop.  So if the lisp interpreter you are using was using applicative order, the function would never return - and no output.

If however, the intepreter used normal order, whereby we expand and apply then performing the necessary steps we get:

1. (test 0 (p))
2. (test (if ... etc) (p))
     the if chooses the option with first zero which does not require y to be evaluated and so (p) is not required to be evaluated.  In which case the function would return zero.


