Ex 1.2

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

=  - 37
    ---
    150

numerator = 14 4/5

denominator = -60


Ex 1.3

(define (sum_sq_largest x y z)
       (cond ((and (< x y) (< x z)) (+ (square y) (square z)))
             ((and (< y x) (< y z)) (+ (square x) (square z)))
             (else (+ (square x) (square y)))))


Ex 1.4

(define (a-plus-abs-b a b)
  (
    (if (> b 0) + 
                -)
       a b)
  )

I think that if (> b 0) condition means + is used otherwise - is used.

So using substitution model:

(a-plus-abs-b 2 3)
(+ 2 3)
5

or alternatively:
(a-plus-abs-b 2 -3)
(- 2 -3)
5

ie 2 - -3

I think the key thing here is that there are two steps above.  First the check whether b is +ve or -ve then 
the corresponding addition or subtraction of a and b

Ex 1.5

The key to answering this question is understanding (define (p) (p))

This function evaluates to ... itself.  so it recursively keeps calling itself - so it never ends.

Therefore, behaviour will be different for normal order and applicative order.

With applicative order, the arguments are evaluated before the function body.  hence (test 0 (p)) will 
evaluate (p) before any of its body and hence be stuck in an endless loop.  So if the lisp interpreter you 
are using was using applicative order, the function would never return - and no output.

If however, the intepreter used normal order, whereby we expand and apply then performing the necessary steps we get:

1. (test 0 (p))
2. (test (if ... etc) (p))
     the if chooses the option with first zero which does not require y to be evaluated and so (p) is not 
     required to be evaluated.  In which case the function would return zero.


Ex 1.6

If you read section 1.1.6 it says:

"Conditional expressions are evaluated as follows. The predicate <p1> is evaluated first. If its value 
is false, then <p2> is evaluated. If <p2>'s value is also false, then <p3> is evaluated. This process 
continues until a predicate is found whose value is true, in which case the interpreter returns the 
value of the corresponding consequent expression <e> of the clause as the value of the conditional 
expression. If none of the <p>'s is found to be true, the value of the cond is undefined."

The key thing here is that the predicate is evaluated and only if true is the expression evaluated.

However, as we know from ex 1.5, the lisp interpreter uses applicative order. This means that ALL the parameters 
are evaluated BEFORE applying the function body.

if does the right thing and first evaluates the guess and either returns guess or calls sqrt-iter.

However, new-if is a function and so the parameters are supposed to be evaluated BEFORE the function body can be called.

if is a special form where applicative order is NOT used.  That is why lisp needs the if as a special form.

Ex 1.7

For calculating really small numbers, the choice of 1 as a starting point means that the guess will need to 
converge down to the number.  The guess will have to drift down to the actual number then go lower.  It would 
be better with numbers < 1 to start guess at x.

The same logic will apply to really large numbers.  There will be a lot of guesses required to drift upwards 
from 1 to the square root of a really large number.  The point was made in the question about precision. 
I assume this means that for very large numbers the integer part of the number will require much of the 
precision bits and so there will be less precision for the floating point part.


Next part of question is how to write a sqrt solution where good-enough? is changed to check the difference 
between guesses.  I found the tricky part was in updating the old-guess.  I worked out that passing the 
sqrt-iter old-guess param as new-guess works.  ie old-guess in new iteration will be previous new-guess!

Here is my attempt:

(define (sqrt2 x)
  (define (small-change? guess previous-guess)
    (< (abs (- guess previous-guess)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter new-guess old-guess)
    (if (small-change? new-guess old-guess)
        new-guess
        (sqrt-iter (improve new-guess) new-guess)))
  (sqrt-iter 1.0 0.0))

It was tricky because if you are used to imperative programming you could just create an old-guess variable 
in a function and update it.  Functional programming doesn't seem to use the assignment to a variable much.

I did jump ahead in the book and read about block structure and free variables.  So this code would be different 
if I hadn't read that.

Results are more precise for small numbers.  I didn't notice any difference with large numbers.

Ex 1.8:

The exercises vary a lot in difficulty.  This was pretty straightforward, just work out the formula in lisp.

This solution uses the block structure described in 1.1.8 page 30.

(define (cuberoot x)
  (define (cube a)
    (* a a a))
  (define (good-enough? guess x)
    (< (abs (- (cube guess) x)) 0.001))
  (define (improve guess x)
    (/ (+ (/ x (* guess guess)) (* 2.0 guess)) 3.0)) 
  (define (cuberoot-iter guess x)
    (if (good-enough? guess x)
        guess
        (cuberoot-iter (improve guess x) x)))
  (cuberoot-iter 1.0 x))
  
  This next solution uses the free variable concept also described in 1.1.8:
  
(define (cuberoot x)
  (define (cube a)
    (* a a a))
  (define (good-enough? guess)
    (< (abs (- (cube guess) x)) 0.001))
  (define (improve guess)
    (/ (+ (/ x (* guess guess)) (* 2.0 guess)) 3.0)) 
  (define (cuberoot-iter guess)
    (if (good-enough? guess)
        guess
        (cuberoot-iter (improve guess))))
  (cuberoot-iter 1.0))
  
  See how x is defined in the outer cuberoot function as a formal parameter.  x is then accessible as a 
  free variable to the nested functions.
  
  
